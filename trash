require('dotenv').config();
const express = require('express');
const cors = require('cors');
const twilio = require('twilio');

const connectDB = require('./config/mongoconnection');
const { verifyToken, routesWithoutToken } = require('./middlewares/authmiddleware');
const { userLogin } = require('./userroutes/userlogin');
const User = require('./models/usermodel');
const Settings = require('./models/settingsmodal');

const app = express();
const PORT = process.env.PORT || 8000;

// Twilio client setup
const client = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

// db connection
connectDB();

app.use(
  cors({
    origin: [
      "*",
      // "https://zap70.com",
      // "http://localhost:3000",
      // "http://167.71.95.212:3000",
      // "http://165.232.134.133:3000",
    ],
    credentials: true,
  })
);

app.use(express.json());

// middlewares
app.use((req, res, next) => {
  if (routesWithoutToken.includes(req.path)) {
    next();
  } else {
    verifyToken(req, res, next);
  }
});

// root route
app.get("/", (req, res) => {
  res.status(200).json({
    status: "success",
    success: true,
    message: "Twilio Server is running!",
  });
  console.log("Root route accessed");
});

app.post("/admin-login", async (req, res) => {
  userLogin(req, res);
});

app.post("/add-user", async (req, res) => {
  try {
    const { phone, status } = req.body;
    let existingUser = await User.findOne({ phone });
    if (existingUser) {
      existingUser.status = status;
      // existingUser.numberOfCall += 1; 
      existingUser.date = Date.now();
      await existingUser.save();
      res.status(200).json({
        status: "success",
        success: true,
        message: "User updated successfully",
        data: existingUser,
      });
    } else {
      const newUser = new User({
        phone,
        status,
      });
      await newUser.save();
      res.status(201).json({
        status: "success",
        success: true,
        message: "User added successfully",
        data: newUser,
      });
    }
  } catch (error) {
    console.log(error);
    res.status(500).json({
      status: "error",
      error: error.message,
      message: "Internal server error",
    });
  }
});

app.get("/users", async (req, res) => {
  try {
    const users = await User.find();
    res.status(200).json({
      status: "success",
      success: true,
      message: "Twilio users fetched successfully",
      Users: users,
    });
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({
      status: "error",
      error: error.message,
      message: "Failed to fetch users",
    });
  }
});

app.post("/log-data", (req, res) => {
  console.log("Received data:", req.body);
  res.status(200).json({
    status: "success",
    success: true,
    message: "Data received and logged successfully",
    data: req.body,
  });
});

app.post("/change-settings", async (req, res) => {
  try {
    const { textMessage, numberOfUsers, numberOfCalls } = req.body;
    await Settings.findOneAndDelete({});
    const newSettings = new Settings({
      textMessage,
      numberOfUsers,
      numberOfCalls,
    });
    await newSettings.save();
    res.status(201).json({
      status: "success",
      success: true,
      message: "Settings added successfully",
      data: newSettings,
    });
  } catch (error) {
    res.status(500).json({
      status: "error",
      error: error.message,
      message: "Failed to add Settings",
    });
  }
});

app.get("/settings", async (req, res) => {
  try {
    const users = await Settings.find();
    res.status(200).json({
      status: "success",
      success: true,
      message: "Twilio Settings fetched successfully",
      Settings: users,
    });
  } catch (error) {
    res.status(500).json({
      status: "error",
      error: error.message,
      message: "Failed to fetch Settings",
    });
  }
});

// Route to make calls to users with pending status
app.post("/make-calls", async (req, res) => {
  try {
    const users = await User.find({ status: "pending" });

    if (users.length === 0) {
      return res.status(200).json({
        status: "success",
        success: true,
        message: "No users with pending status",
      });
    }

    const calls = users.map(user => {
      return client.calls.create({
        to: user.phone,
        from: process.env.TWILIO_PHONE_NUMBER,
        twiml: `<Response><Say>Your pending status needs attention. Please take the necessary actions.</Say></Response>`,
      }).then(call => {
        user.status = "called";
        user.date = Date.now();
        return user.save();
      });
    });

    await Promise.all(calls);

    res.status(200).json({
      status: "success",
      success: true,
      message: "Calls initiated to all pending users",
    });
  } catch (error) {
    console.error("Error making calls:", error);
    res.status(500).json({
      status: "error",
      error: error.message,
      message: "Failed to initiate calls",
    });
  }
});

//server
app.listen(PORT, () => {
  console.log("==================================");
  console.log(`Server is running on port ${PORT}`);
});


















//////////////////////////////////////////////////////////////////////
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
  res.send('Hello, world!');
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});


const express = require('express');
const app = express();
const port = 7000;


app.get('/', (req, res) => {

})
app.listen(port, () => {
  console.log(`server chal rha hy ${post} ki speed py`)
})
























const express = require('express')
const app = express()
const port = 7000

app.get('/', (req, res) => {
  res.send('Fahad ka server');
});




app.listen(port, () => {
  console.log(`server is running at a speed of ${port} km/h`)
})

































function makeCall(parentIndex, childIndex) {
  console.log('This is the Child index = ', childIndex);
  
  const agentsForParent = availableAgents[parentIndex];
  if (!agentsForParent || !agentsForParent[childIndex]) {
      console.log('Invalid child index. No agent available at this index.');
      if (childIndex <= Object.keys(agentsForParent).length) {
        console.log('Continuing with next agent if available.');
        makeCall(parentIndex, 1);
      } else {
        console.log('Retrying from the beginning.');
        makeCall(parentIndex, 1);
        return;
      }
    }
    

  var tableName = 'Round Robin Assign Table copy';
  const agent = agentsForParent[childIndex];
  const agentName = agent.AgentName;
  const clientId = agent.ClientID;
  const summary = agent.summary;
  const timeoutSeconds = 15;
  const requestData = {
    clientId: clientId,
    agentName: agentName,
    summary: summary,
    fromNumber: agent.twilio_phone_number,
    agentNumber: agent.agent_phone_number,
    clientNumber: agent.phone_number
  };
  
  console.log(clientId)
  console.log('Agent Name:', agentName);
  console.log('this is the parent index', parentIndex);
  console.log("This is the summary = ", summary)
  const base = new Airtable({apiKey: API_KEY}).base(BASE_ID);
  base(tableName).select({
      filterByFormula: `AND({Client ID} = '${clientId}')`
  }).eachPage(function page(records, fetchNextPage) {
      if (records.length === 0) {
          console.log('No existing record found. Creating a new record.');
          let value = String(childIndex);
          console.log('This is the source value that will be updated after creating the row beacause no row was found = ',value)
          base(tableName).create({
              'Client ID': clientId,
              'Last Assigned Agent': agentName,
              'Source': value
  
          }, function(err, record) {
              if (err) {
                  console.error('Error creating record:', err);
                  return;
              }
              console.log('Created new record with ID:', record.id);
          });
      } else {
          console.log(`Retrieved ${records.length} records:`);
          records.forEach(record => {
              console.log(`Updating record with ID: ${record.id}`);
              let value = String(childIndex);
              console.log('This is the source value that will be update to the table = ',value)
              base(tableName).update(record.id, {
                  'Last Assigned Agent':agentName,
                  'Source': value
              }, function(err, updatedRecord) {
                  if (err) {
                      console.error('Error updating record:', err);
                  }
                  console.log(`Updated record ID: ${record.id}, Source: ${updatedRecord.fields.Source}`);
              });
          });
      }
      fetchNextPage();
  }, function done(err) {
      if (err) {
          console.error('Error:', err);
      }
      console.log('Done');
  });
  


  client.calls
    .create({
      twiml: `
      <Response>
        <Gather numDigits="1" action="http://16.171.12.106/gather?parentIndex=${encodeURIComponent(parentIndex)}&amp;childIndex=${encodeURIComponent(childIndex)}&amp;requestData=${encodeURIComponent(JSON.stringify(requestData))}" method="POST">
          <Say>${'If you want to accept this call please press 1 '}</Say>
        </Gather>
      </Response>
      `,      
      to: agent.agent_phone_number,
      from: agent.twilio_phone_number,
      machineDetection: 'Enable',
      asyncAmd: true,
      asyncAmdStatusCallback: `http://16.171.12.106/twilio-status?parentIndex=${encodeURIComponent(parentIndex)}&childIndex=${encodeURIComponent(childIndex)}&requestData=${encodeURIComponent(JSON.stringify(requestData))}`,
      asyncAmdStatusCallbackMethod: 'POST',
      statusCallback: `http://16.171.12.106/twilio-callback?parentIndex=${encodeURIComponent(parentIndex)}&childIndex=${encodeURIComponent(childIndex)}&requestData=${encodeURIComponent(JSON.stringify(requestData))}`,
      statusCallbackMethod: 'POST',
      timeout: timeoutSeconds,
      statusCallbackEvent: ['answered', 'ringing', 'in-progress','completed'],
      requestData: requestData
    })
    .then(call => {
      console.log(`Call initiated to agent ${parentIndex}/${childIndex}. Call SID: ${call.sid}`)
    })
    .catch(error => {
      console.error(`Failed to call agent ${parentIndex}/${childIndex}: ${error}`);
      if (childIndex < Object.keys(availableAgents[parentIndex]).length) {
        currentAgentIndex.child = childIndex + 1; // Update currentAgentIndex
        console.log('This is the index', currentAgentIndex.child);
        makeCall(parentIndex, currentAgentIndex.child);
      } else {
        console.log('All agents are busy or unavailable. Retrying from the beginning.');
        currentAgentIndex.child = 1;
        console.log('This is the index', currentAgentIndex.child);
        makeCall(parentIndex, currentAgentIndex.child);
      }
    });
}













        // console.log("Twilio Call Details:", callDetails.data);
        // if (callDetails.data.status === 'completed' || callDetails.data.status === 'in-progress') {
        //   console.log(`Call to ${callDetails.data.to} was answered.`);
        //   await User.updateOne({ phone: to }, { status: 'Answered' });
        //   console.log(`User with phone ${to} call status updated to 'Answered'`);
        // } else {
        //   console.log(`Call to ${callDetails.data.to} was not answered.`);
        // }




        app.post("/api/make-call", async (req, res) => {
          try {
            const currentHourET = moment().tz('America/New_York').hour();
            if (currentHourET < 9 || currentHourET >= 17) {
              return res.status(400).json({
                status: "error",
                message: "Calls can only be made between 9 AM and 5 PM Eastern Time",
              });
            }
        
            const phoneNumbers = await getUserPhone();
            console.log("Phone numbers to call:", phoneNumbers);
            if (phoneNumbers.length === 0) {
              return res.status(400).json({
                status: "error",
                message: "No phone numbers to call",
              });
            }
        
            const failedCalls = [];
            for (let i = 0; i < phoneNumbers.length; i++) {
              const to = phoneNumbers[i];
              try {
                const call = await client.calls.create({
                  from: process.env.TWILIO_PHONE_NUMBER,
                  to: to.toString(),
                  url: "http://demo.twilio.com/docs/voice.xml",
                  // method: "GET",
                  statusCallback: "https://431c-154-192-30-63.ngrok-free.app/callstatus",
                  statusCallbackMethod: "POST",
                  statusCallbackEvent: ['answered', 'ringing', 'completed'],
                });
                console.log(`Call initiated successfully to ${to}. Call SID: ${call.sid}`);
                await User.updateOne({ phone: to }, { $inc: { numberOfCall: 1 } });
                await new Promise(resolve => setTimeout(resolve, 5000));
                const callDetails = await axios.get(`https://api.twilio.com/2010-04-01/Accounts/${process.env.TWILIO_ACCOUNT_SID}/Calls/${call.sid}.json`, {
                  auth: {
                    username: process.env.TWILIO_ACCOUNT_SID,
                    password: process.env.TWILIO_AUTH_TOKEN,
                  },
                });
              } catch (error) {
                console.error(`Failed to make call to ${to}:`, error);
                failedCalls.push(to);
              }
            }
        
            if (failedCalls.length > 0) {
              return res.status(500).json({
                status: "error",
                message: "Failed to make some calls",
                failedNumbers: failedCalls,
              });
            } else {
              res.status(200).json({
                status: "success",
                message: "All calls initiated successfully",
              });
            }
          } catch (error) {
            console.error("Error making calls:", error);
            res.status(500).json({
              status: "error",
              message: "Failed to make calls",
              error: error.message,
            });
          }
        });